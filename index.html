<!--
3D Maze Game - index.html
Author: Generated by ChatGPT
Description: Single-file 3D maze game using Three.js. Host on GitHub Pages by placing this file as `index.html` in the repository root and enabling Pages.
How to use:
 1. Create a new GitHub repo, upload this index.html into the repo root.
 2. In repo settings -> Pages -> Source: main branch / root. Save.
 3. Open the provided Pages URL after a minute.

Controls:
 - Click the screen to lock pointer and control the camera.
 - W A S D to move, Space to jump, Shift to run.
 - Find the cat to win. Avoid the monsters.

Difficulty settings adjust maze size and monster count.
--><!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Maze â€” Find the Cat</title>
  <style>
    :root{
      --bg:#0f1724; --accent:#06b6d4; --card:rgba(255,255,255,0.04);
      --glass: rgba(255,255,255,0.04);
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#061122 0%, #071827 60%);font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    #overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    #ui{width:340px;padding:18px;border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));backdrop-filter:blur(6px);box-shadow:0 8px 30px rgba(2,6,23,0.7);color:#e6eef6;pointer-events:auto}
    h1{margin:0 0 6px;font-size:20px}
    p.small{margin:4px 0 12px;color:#98a3b3;font-size:13px}
    .row{display:flex;gap:8px;align-items:center}
    select,button{width:100%;padding:10px;border-radius:10px;border:0;background:var(--card);color:inherit;font-weight:600}
    .muted{color:#9aa8b8;font-size:13px}
    #hud{position:fixed;left:16px;top:16px;padding:8px 12px;border-radius:12px;background:linear-gradient(180deg, rgba(3,6,12,0.6), rgba(3,6,12,0.4));color:#dff6fb;font-weight:600;backdrop-filter:blur(4px)}
    #message{position:fixed;right:16px;top:16px;padding:10px 14px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));color:#fff;font-weight:700}
    #footer{margin-top:12px;font-size:12px;color:#9fb2c2}
    #canvas-holder{position:fixed;inset:0}
    #start-tip{font-size:13px;color:#bcdbe3;margin-top:8px}
    #mini-help{margin-top:10px;font-size:13px;color:#9ab1bf}
    .flex{display:flex;gap:8px}
    .ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
    .danger{background:linear-gradient(90deg,#ff6b6b,#ff3b3b)}
  </style>
</head>
<body>
  <div id="canvas-holder"></div>  <div id="overlay">
    <div id="ui">
      <h1>Find the Cat â€” 3D Maze</h1>
      <p class="small">Modern minimal 3D maze. Click Start, lock pointer, and navigate with WASD. Find the cat to win. Touching monsters kills you.</p><label class="muted">Difficulty</label>
  <select id="difficulty">
    <option value="easy">Easy (11Ã—11)</option>
    <option value="medium" selected>Medium (21Ã—21)</option>
    <option value="hard">Hard (31Ã—31)</option>
  </select>

  <div style="height:10px"></div>
  <div class="row">
    <button id="startBtn">Start Game</button>
    <button id="resetBtn" class="ghost">Reset</button>
  </div>

  <div id="start-tip">Click the 3D view to lock pointer after starting. Use shift to run.</div>
  <div id="footer">Made to host on GitHub Pages â€¢ Minimal assets</div>
</div>

  </div>  <div id="hud">Health: <span id="health">100</span> &nbsp;|&nbsp; Time: <span id="time">0</span>s</div>
  <div id="message" style="display:none"></div>  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/PointerLockControls.js';

    // ---- Config / UI ----
    const container = document.getElementById('canvas-holder');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const difficultyEl = document.getElementById('difficulty');
    const messageEl = document.getElementById('message');
    const healthEl = document.getElementById('health');
    const timeEl = document.getElementById('time');

    let scene, camera, renderer, controls, clock;
    let maze = [];
    let mazeSize = 21; // default medium
    const CELL = 4; // world units per cell
    let wallsGroup, objectsGroup, monsters = [];
    let player = { speed: 4, runMultiplier: 1.8, pos: new THREE.Vector3(), alive: true };
    let startTime = 0;
    let catPos = null;
    let keys = {};
    let lastTime = performance.now();

    function initThree(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x071827);
      camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.shadowMap.enabled = true;
      container.innerHTML = '';
      container.appendChild(renderer.domElement);

      // lights
      const hemi = new THREE.HemisphereLight(0xbfeaff, 0x080820, 0.6);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xddeeff, 0.8);
      dir.position.set(10,20,10);
      dir.castShadow = true;
      dir.shadow.mapSize.set(1024,1024);
      scene.add(dir);

      // ground
      const groundGeo = new THREE.PlaneGeometry(500,500);
      const groundMat = new THREE.MeshStandardMaterial({color:0x071827, metalness:0.1, roughness:0.9});
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI/2;
      ground.receiveShadow = true;
      scene.add(ground);

      wallsGroup = new THREE.Group(); wallsGroup.name = 'walls'; scene.add(wallsGroup);
      objectsGroup = new THREE.Group(); scene.add(objectsGroup);

      // controls
      controls = new PointerLockControls(camera, renderer.domElement);
      controls.getObject().position.set(0,1.6,0);
      scene.add(controls.getObject());

      clock = new THREE.Clock();

      window.addEventListener('resize', onWindowResize);
      document.addEventListener('keydown', e=>keys[e.code]=true);
      document.addEventListener('keyup', e=>keys[e.code]=false);

      renderer.domElement.addEventListener('click', ()=>{
        if(started && !controls.isLocked) controls.lock();
      });
    }

    function onWindowResize(){
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }

    // ---- Maze generation (recursive backtracker) ----
    function generateMaze(n){
      // n must be odd -> interior cells
      maze = new Array(n).fill(0).map(()=>new Array(n).fill(1)); // 1 = wall, 0 = path
      function carve(x,y){
        maze[y][x] = 0;
        const dirs = [[2,0],[-2,0],[0,2],[0,-2]].sort(()=>Math.random()-0.5);
        for(const [dx,dy] of dirs){
          const nx = x+dx, ny = y+dy;
          if(nx>0 && ny>0 && nx<n-1 && ny<n-1 && maze[ny][nx]===1){
            maze[y+dy/2][x+dx/2] = 0;
            carve(nx,ny);
          }
        }
      }
      carve(1,1);
      // ensure entrance and exit
      maze[1][0]=0; maze[n-2][n-1]=0;
      return maze;
    }

    function buildMazeMesh(){
      wallsGroup.clear(); objectsGroup.clear(); monsters = [];
      const wallMat = new THREE.MeshStandardMaterial({color:0x0f1724, metalness:0.2, roughness:0.7});
      const wallGeo = new THREE.BoxGeometry(CELL,3,CELL);
      const half = (mazeSize/2)*CELL;
      for(let y=0;y<mazeSize;y++) for(let x=0;x<mazeSize;x++){
        if(maze[y][x]===1){
          const mx = (x - mazeSize/2)*CELL + CELL/2;
          const mz = (y - mazeSize/2)*CELL + CELL/2;
          const box = new THREE.Mesh(wallGeo, wallMat);
          box.position.set(mx,1.5,mz);
          box.castShadow = true; box.receiveShadow = true;
          wallsGroup.add(box);
        }
      }

      // set player start at maze coordinate (1,1)
      const startX = (1 - mazeSize/2)*CELL + CELL/2;
      const startZ = (1 - mazeSize/2)*CELL + CELL/2;
      controls.getObject().position.set(startX,1.6,startZ);
      player.pos.set(startX,1.6,startZ);

      // place cat near far corner (n-2,n-2 or nearest path cell)
      let found = false;
      for(let r=0;r<mazeSize && !found;r++){
        for(let y=mazeSize-2;y>0 && !found;y--){
          for(let x=mazeSize-2;x>0 && !found;x--){
            if(maze[y][x]===0){
              const cx = (x - mazeSize/2)*CELL + CELL/2;
              const cz = (y - mazeSize/2)*CELL + CELL/2;
              placeCat(cx,cz);
              catPos = new THREE.Vector3(cx,1.2,cz);
              found = true;
            }
          }
        }
      }

      // choose monster positions: pick some dead-end or corners
      const monsterCount = difficultyEl.value==='easy'?3:(difficultyEl.value==='medium'?7:15);
      const candidates = [];
      for(let y=1;y<mazeSize-1;y++) for(let x=1;x<mazeSize-1;x++) if(maze[y][x]===0){
        // count adjacent paths
        let adj = 0; [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{ if(maze[y+dy][x+dx]===0) adj++; });
        if(adj<=2){ candidates.push({x,y}); }
      }
      for(let i=0;i<monsterCount && candidates.length;i++){
        const idx = Math.floor(Math.random()*candidates.length);
        const {x,y} = candidates.splice(idx,1)[0];
        const mx = (x - mazeSize/2)*CELL + CELL/2;
        const mz = (y - mazeSize/2)*CELL + CELL/2;
        spawnMonster(mx,mz);
      }

      // neat ambient objects
      const pillarGeo = new THREE.CylinderGeometry(0.6,0.6,2.5,12);
      const pillarMat = new THREE.MeshStandardMaterial({color:0x0b6b6b, metalness:0.4, roughness:0.6});
      for(let i=0;i<10;i++){
        const px = (Math.random()*mazeSize - mazeSize/2)*CELL;
        const pz = (Math.random()*mazeSize - mazeSize/2)*CELL;
        const pillar = new THREE.Mesh(pillarGeo, pillarMat);
        pillar.position.set(px,1.25,pz);
        pillar.scale.setScalar(0.6+Math.random()*0.8);
        objectsGroup.add(pillar);
      }
    }

    function placeCat(x,z){
      // simple stylized cat made from boxes
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.6,0.8), new THREE.MeshStandardMaterial({color:0xffc24d, metalness:0.2, roughness:0.6}));
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshStandardMaterial({color:0xffd37a}));
      head.position.set(0,0.6,0.4);
      const earGeom = new THREE.BoxGeometry(0.18,0.2,0.12);
      const ear1 = new THREE.Mesh(earGeom, head.material); ear1.position.set(-0.18,0.96,0.6);
      const ear2 = ear1.clone(); ear2.position.set(0.18,0.96,0.6);
      g.add(body, head, ear1, ear2);
      g.position.set(x,0.6,z);
      g.name = 'cat';
      objectsGroup.add(g);
    }

    function spawnMonster(x,z){
      const m = {
        mesh: null,
        origin: new THREE.Vector3(x,0.6,z),
        pos: new THREE.Vector3(x,0.6,z),
        dir: Math.random()*Math.PI*2,
        speed: 1 + Math.random()*1.5
n      };
      const geo = new THREE.SphereGeometry(0.5,16,16);
      const mat = new THREE.MeshStandardMaterial({color:0xff5b5b, emissive:0x2a0000, metalness:0.2, roughness:0.6});
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow=true; mesh.position.copy(m.pos);
      m.mesh = mesh;
      monsters.push(m);
      scene.add(mesh);
    }

    // ---- Game loop and movement ----
    let started = false;
    function startGame(){
      // set maze size by difficulty
      const diff = difficultyEl.value;
      if(diff==='easy') mazeSize = 11; else if(diff==='medium') mazeSize = 21; else mazeSize = 31;
      if(mazeSize%2===0) mazeSize++;
      generateMaze(mazeSize);
      buildMazeMesh();
      startTime = performance.now();
      started = true; player.alive = true; healthEl.textContent = '100';
      messageEl.style.display='none'; timeEl.textContent='0';
      // lock pointer on start click
      controls.lock();
    }

    function resetGame(){
      started=false; // unlock / reset
      messageEl.style.display='none';
      // scene cleanup
      wallsGroup.clear(); objectsGroup.clear(); monsters.forEach(m=>scene.remove(m.mesh)); monsters=[];
      // position camera to outside above
      controls.getObject().position.set(0,50,0);
    }

    function update(delta){
      if(!started) return;
      // movement
      const forward = (keys['KeyW']?1:0) - (keys['KeyS']?1:0);
      const strafe = (keys['KeyD']?1:0) - (keys['KeyA']?1:0);
      let speed = player.speed*(keys['ShiftLeft']||keys['ShiftRight']?player.runMultiplier:1);
      if(!controls.isLocked) { speed=0; }
      const dir = new THREE.Vector3();
      controls.getDirection(dir);
      // dir is unit vector of camera forward
      const right = new THREE.Vector3(); right.crossVectors(dir, new THREE.Vector3(0,1,0)).normalize();
      const move = new THREE.Vector3();
      move.addScaledVector(dir, forward);
      move.addScaledVector(right, strafe);
      if(move.length()>0) move.normalize().multiplyScalar(speed*delta);

      // collision naive: try move, if collides with walls revert
      const nextPos = controls.getObject().position.clone().add(move);
      // limit y
      nextPos.y = 1.6;
      const collided = checkWallCollision(nextPos);
      if(!collided){ controls.getObject().position.copy(nextPos); player.pos.copy(nextPos); }

      // monsters update
      for(const m of monsters){
        // simple wander: move along dir, if collides with wall or random turn
        const mv = new THREE.Vector3(Math.cos(m.dir),0,Math.sin(m.dir)).multiplyScalar(m.speed*delta);
        const attempt = m.pos.clone().add(mv);
        if(checkWallCollision(attempt) || Math.random()<0.01){ m.dir += (Math.random()-0.5)*Math.PI; }
        else { m.pos.copy(attempt); m.mesh.position.copy(m.pos); }

        // check collision with player
        const dist = m.pos.distanceTo(player.pos);
        if(dist < 1.0 && player.alive){
          player.alive=false; showMessage('You Died â€” A monster got you', false);
        }
      }

      // cat check
      if(catPos && player.pos.distanceTo(catPos) < 1.2){
        showMessage('You Found the Cat! You Win ðŸŽ‰', true);
        started=false;
      }

      // time
      const secs = Math.floor((performance.now()-startTime)/1000);
      timeEl.textContent = secs;
    }

    function showMessage(txt, win){
      messageEl.style.display='block'; messageEl.textContent = txt;
      messageEl.style.background = win ? 'linear-gradient(90deg,#4ade80,#10b981)' : 'linear-gradient(90deg,#ff6b6b,#ff3b3b)';
      // unlock pointer
      try{ controls.unlock(); }catch(e){}
    }

    function checkWallCollision(pos){
      // check against wallsGroup bounding boxes
      const px = pos.x, pz = pos.z;
      for(const w of wallsGroup.children){
        const b = new THREE.Box3().setFromObject(w);
        // inflate player radius
        b.expandByScalar(-0.5);
        if(px > b.min.x && px < b.max.x && pz > b.min.z && pz < b.max.z) return true;
      }
      return false;
    }

    function animate(){
      const now = performance.now();
      const delta = Math.min((now - lastTime)/1000, 0.05);
      lastTime = now;
      requestAnimationFrame(animate);
      update(delta);
      renderer.render(scene, camera);
    }

    // ---- Init and UI hookups ----
    initThree();
    animate();

    startBtn.addEventListener('click', ()=>{
      startGame();
    });
    resetBtn.addEventListener('click', ()=>{ resetGame(); });

    // set initial camera
    controls.getObject().position.set(0,50,0);

    // show small instructions in console
    console.log('3D Maze ready â€” choose difficulty and press Start');
  </script></body>
</html>
